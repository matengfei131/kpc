import {eachChildren} from '../utils';
import {makeStyles} from './styles';
import {isStringOrNumber, isNull} from 'intact-shared';
import {getClassAndStyleForFixed} from './useFixedColumns';
import {Affix} from '../affix';
import {TableRow} from './row';
import {Checkbox} from '../checkbox';
import {context as GroupContext} from './useGroup';
import {context as SortableContext} from './useSortable';
import {Spin} from '../spin';
import {Transition, TransitionGroup, createComponentVNode} from 'intact';
import {_$} from '../../i18n';
import {context as TableContext} from './useColumns';
import {expandAnimationCallbacks} from '../utils';
import {Tooltip} from '../tooltip';
import {AllCheckedStatus} from './useChecked';
import {context as ResizableContext} from './useResizable';
import {context as FixedColumnsContext} from './useFixedColumns';

const {
    data, children, className, fixHeader,
    checkType, rowKey, type, stripe,
    rowClassName, group, sort, loading,
    merge, childrenKey, indent, tooltipPosition,
    tooltipContainer, showIndeterminate, resizable,
    draggable,
} = this.get();
const {columns, cols, maxRows, maxCols} = this.columns.getData();
const {onScroll, scrollPosition, hasFixed, getHasFixedLeft, getOffsetMap} = this.fixedColumns;
const {stickHeader, excludeStickHeader, elementRef, scrollRef, headRef} = this.stickyHeader;
const classNameObj = {
    'k-table': true,
    'k-fix-header': fixHeader,
    [`k-scroll-${scrollPosition.value}`]: scrollPosition.value,
    'k-fix-columns': hasFixed.value,
    [`k-${type}`]: type && type !== 'default',
    'k-stripe': stripe,
    'k-with-expand': $blocks.expand,
    [className]: className,
    [makeStyles()]: true,
};
const style = isStringOrNumber(fixHeader) ? 
    {maxHeight: `${fixHeader}px`} :
    null;

const {getWidth, start: onStart, tableRef, tableWidth} = this.resizable;

const colgroup = (
    <colgroup>
        <col v-if={checkType !== 'none'} width="40" />
        <col v-for={cols} 
            width={$value.width}
            style={{width: getWidth($value.key)}}
            class={{[$value.className]: $value.className}}
        />
    </colgroup>
);
const hasData = data && data.length;

const hasFixedLeft = getHasFixedLeft();
const {getAllCheckedStatus, toggleCheckedAll, getAllStatus, onChangeChecked} = this.checked;
const allCheckedStatus = getAllCheckedStatus(); 
const offsetMap = getOffsetMap();
const thead = (
    <TableContext.Provider value={checkType}>
        <GroupContext.Provider value={{group, onChange: this.onChangeGroup}}>
            <SortableContext.Provider value={{sort, onChange: this.sortable.onChange}}>
                <ResizableContext.Provider value={{resizable, onStart}}>
                    <FixedColumnsContext.Provider value={offsetMap}>
                        <thead>
                            <tr v-for={columns}>
                                <th v-if={$key === 0 && checkType !== 'none'}
                                    {...getClassAndStyleForFixed({
                                        fixed: hasFixedLeft ? 'left' : false,
                                    }, 0)} 
                                    rowspan={maxRows}
                                >
                                    <Checkbox v-if={checkType === 'checkbox'}
                                        value={allCheckedStatus === AllCheckedStatus.All}
                                        indeterminate={showIndeterminate && allCheckedStatus == AllCheckedStatus.Indeterminate}
                                        ev-$change:value={toggleCheckedAll}
                                        disabled={!hasData}
                                    />
                                </th>
                                {$value}
                            </tr>
                        </thead>
                    </FixedColumnsContext.Provider>
                </ResizableContext.Provider>
            </SortableContext.Provider>
        </GroupContext.Provider>
    </TableContext.Provider>
);

const {getAllKeys} = this.disableRow;
const {getGrid} = this.merge;
const allStatus = getAllStatus();
const allKeys = getAllKeys();
const colCount = maxCols + (checkType !== 'none' ? 1 : 0);
const {isExpanded} = this.expandable;
const {isSelected} = this.selected;
const {loopData, isSpreaded, toggleSpreadRow} = this.tree;
const {onRowDragStart, onRowDragOver, onRowDragEnd, draggingKey} = this.draggable;
const tbody = (
    <TransitionGroup tag="tbody" name="k-fade" move={!draggingKey.value}>
        {!hasData ? 
            <tr key="table-empty">
                <td colspan={colCount} class="k-table-empty">
                    <b:empty>{_$('/(ㄒoㄒ)/~~ 没有找到亲要的数据哦~')}</b:empty>
                </td>
            </tr> :
            (() => {
                const rows = [];
                loopData((value, index, level, hidden) => {
                    const status = allStatus[index];
                    const key = allKeys[index];
                    const spreaded = isSpreaded(key);
                    const hasChildren = !!childrenKey && Array.isArray(value[childrenKey]);
                    const indentSize = indent ? indent * level : 0; 

                    let row = <TableRow
                        key={key}
                        cols={cols}
                        data={value}
                        checkType={checkType}
                        hasFixedLeft={hasFixedLeft}
                        onClick={this.clickRow}
                        checked={status.checked}
                        indeterminate={status.indeterminate}
                        index={index}
                        disabled={status.disabled}
                        allDisabled={status.allDisabled}
                        className={rowClassName && rowClassName(value, index, key)}
                        merge={merge}
                        grid={getGrid()}
                        onChangeChecked={onChangeChecked}
                        selected={isSelected(key)}
                        spreaded={spreaded}
                        hidden={hidden}
                        hasChildren={hasChildren}
                        indent={indentSize}
                        onToggleSpreadRow={toggleSpreadRow}
                        onBeforeUnmount={this.resetRowStatus.onRowBeforeUnmount}
                        offsetMap={offsetMap}

                        draggable={draggable}
                        draggingKey={draggingKey.value}
                        onRowDragStart={onRowDragStart}
                        onRowDragEnd={onRowDragEnd}
                        onRowDragOver={onRowDragOver}
                    />

                    if ($blocks.tooltip) {
                        const content = <b:tooltip params={[value, index]} />;
                        row = (
                            <Tooltip key={key} position={tooltipPosition} container={tooltipContainer}>
                                <template>{row}</template>
                                <b:content>{content}</b:content>
                            </Tooltip>
                        );
                    }

                    rows.push(row);
                    if ($blocks.expand) {
                        const expanded = isExpanded(key);
                        rows.push(
                            <tr class={{"k-expand": true, 'k-expanded': expanded}}
                                key={`${key}.$expand`}
                            >
                                <td colspan={colCount}>
                                    <Transition {...expandAnimationCallbacks}>
                                        <div v-if={expanded} class="k-table-expand">
                                            <b:expand params={[value, index]} />
                                        </div>
                                    </Transition>
                                </td>
                            </tr>
                        );
                    }

                    return hidden || !spreaded;
                });

                return rows;
            })()
        }
    </TransitionGroup>
);

const tableWidthPx = tableWidth.value ? `${tableWidth.value}px` : null;
<div class={classNameObj} ref={elementRef}>
    <div class="k-table-wrapper" style={style} ev-scroll={onScroll} ref={scrollRef}>
        <Affix v-if={!isNull(stickHeader.value)}
            top={stickHeader.value}
            exclude={excludeStickHeader}
            class="k-table-affix-header"
        >
            <table ref={headRef} style={{width: tableWidthPx}}>
                <template>{colgroup}</template>
                <template>{thead}</template>
            </table>
        </Affix>
        <table ref={tableRef} style={{width: tableWidthPx}}>
            <template>{colgroup}</template>
            <template v-if={isNull(stickHeader.value)}>{thead}</template>
            <template>{tbody}</template>
        </table>
    </div>
    <Transition name="k-fade">
        <Spin v-if={loading} overlay size="small" class="k-table-spin" />
    </Transition>
</div>
